## メタruby
- 気づかないうちに他のモジュールやクラスと名前が被ってて気付きにくい時があるので、ネームスペースを積極的に使う
- A→（class）→Bの関係の時、AはインスタンスでBがクラス
- 何かのインスタンスがある時、その継承チェーンは、インスタンスのクラス、そのスーパークラス（継承元）、そのスーパークラス（継承元）。。となる。
- もしクラスにモジュールをインクルードしている場合はそのモジュールも継承チェーンに入る（そのクラスの上に入る）
- ちなみにincludeではなくprependでモジュールを入れると、そのクラスの下にモジュールが入る（継承チェーンの話）
- たとえばインスタンスに対してメソッドを呼び出しを行なった際、メソッド探索が行われ、それは継承チェーンの順番にメソッドを探しにく。
- 対象のメソッドを見つけた場合、そのオブジェクト（レシーバ）をカレントオブジェクトにする（selfにする）
- 何のオブジェクトもない状態でirbとかでいきなりselfを呼ぶとrubyが作り出したmainというのがselfになる。（トップレベルコンテキスト）
- privateメソッドは明示的にレシーバを指定して呼び出せない。また、クラスが同じでも違うオブジェクトのメソッドを呼ぶためにはレシーバを指定する必要がある。つまり、privateメソッドは自分（もしくは継承チェーンにあるオブジェクト）からしか呼び出せない
- ちなみに、privateはレシーバをつけちゃダメなので、たとえ自身であったとしてもselfをつけたら呼び出せない。
- refine/usingを使えば、グローバルでないモンキーパッチ（オープンクラスして）できる
- 全てのインスタンスは独立したインスタンス変数を持ってる。クラスでインスタンス変数を持っていても、inicializeされたりしてないなら、クラスの持ってるインスタンス変数とクラスのオブジェクト（インスタンス）が持ってるインスタンス変数は全く別物になる
- `self.class_method @my_val; end `みたいなのがクラスにある時、@my_valはクラスインスタンス変数で、インスタンスからは参照できない。
- `attr_accessor`がよくわかってなかったけど、getter/とsetterを勝手に作ってくれるだけの便利なやつ
